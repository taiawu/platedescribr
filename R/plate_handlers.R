#' Extract plate dimensions
#'
#' @description
#' Extract the suspected plate row or column from a well name, or vector of well names.
#'
#' * `extract_plate_row()` returns suspected rows, for example, "A", from "A1". Specifically, returns the character element of the supplied well name(s).
#'
#' * `extract_plate_col()`, returns suspected columns, for example, "1", from "A1". Specifically, returns the numeric element of the supplied well name(s).
#'
#' @param well_names A character vector containing well names, e.g. c("A1", "A2", "B1", "B2").
#'
#'
#' @family plate helpers
#' @export
#'
#' @examples
#' # extract the suspected plate row
#' extract_plate_row(c("A1", "A2", "B1", "B2"))
#' # [1] "A" "A" "B" "B"
#'
#' # extract the suspected plate co()lumn
#' extract_plate_col(c("A1", "A2", "B1", "B2"))
#' # [1] 1 2 1 2
#'
#' @describeIn plate_dimensions Extract the plate row from a well name
#' @export
extract_plate_row <- function(well_names) {
  # remove any digits from well name
  gsub("[0-9]+", "", well_names)
}

#' @describeIn plate_dimensions Extract the plate column from a well name
#' @export
extract_plate_col <- function(well_names) {
  as.numeric(gsub("\\D", "", well_names))
}

#' Create well names from plate dimensions
#'
#' Creates well names from all possible combinations of input plate rows and columns.
#'
#' @param plate_rows A vector where each element is a plate row to be included in the output well names, e.g. c("A", "B").
#' @param plate_cols A vector where each element is a plate column to be included in the output well names, e.g. c(1, 2).
#' @param .leading_zeroes Whether to add leading zeroes to numeric `plate_cols` in the final well names (e.g. "A01").
#'
#' @importFrom dplyr arrange mutate if_else
#'
#' @return A character vector where each entry is a unique well name generated by combining the plate rows and columns , e.g. c("A1", "A2", "B1", "B2").
#' @export
#'
#' @examples
#'
#' dimensions_to_wells(plate_rows = c("A", "B"), plate_cols = c(8:10))
#' # [1] "A8"  "B8"  "A9"  "B9"  "A10" "B10"
#'
#' # leading zeroes can be added to well names
#' dimensions_to_wells(plate_rows = c("A", "B"), plate_cols = c(8:10), .leading_zeroes = TRUE)
#' # [1] "A08" "B08" "A09" "B09" "A10" "B10"
#'
dimensions_to_wells <- function(plate_rows, plate_cols, .leading_zeroes = FALSE) {
  if (is.null(plate_rows) | is.null(plate_cols)) {
    # ensure entries are not NULL -- expand.grid will silently output a corrupt dataframe
    stop("Please supply a non-null vector to both 'plate_rows' and 'plate_cols'.")
  } else {
    expanded <- expand.grid("rows" = plate_rows, "cols" = plate_cols) |>
      arrange(.data$rows)

    # add leading zeroes to columns under 10 if requested
    if (.leading_zeroes) {
      expanded <- expanded |>
        mutate("cols" = if_else(.data$cols < 10,
          true = paste0("0", as.character(.data$cols)),
          false = as.character(.data$cols)
        ))
    }

    out <- expanded |>
      do.call(paste0, args = _) |>
      unique() # remove duplicate wells
  }

  out
}


#' Add wells not included in a layout
#'
#' If a layout does not contain every well for a given plate type (e.g. 384),
#' add the missing wells. Assign "NA" for all experimental variables.
#'
#' @param layout A layout tibble
#' @param .well_col A string--the name of the column that holds the well
#' @param ... Unused, for extensibility.
#' @inheritParams make_well_names
#'
#' @importFrom dplyr tibble right_join mutate
#' @importFrom rlang :=
#'
#' @return the same layout, but with all wells in the chosen plate type
#' @export
add_missing_wells <- function(layout,
                              plate_type = "384",
                              .well_col = "well",
                              ...) {
  # generate well names for full plate
  wells <- tibble("{.well_col}" := make_well_names(plate_type, ...))

  filled <- right_join(layout, wells, by = .well_col)

  # add plate row and column, if layout has these
  if ("row" %in% names(layout) & "column" %in% names(layout)) {
    filled <- filled |>
      mutate(
        "row" = extract_plate_row(.data[[.well_col]]), # will [[.well_col]] work in a package?
        "column" = extract_plate_col(.data[[.well_col]])
      ) # will [[.well_col]] work in a package?
  }

  filled
}

#' Generate well names for a given plate
#'
#' Given either a plate type (e.g. `96`, `384`, or `"custom"`), generate a vector containing the names of all wells in that plate.
#'
#' @param plate_type The type of plate to make well names for; can be
#'   * `96`, for 96 well plates.
#'   * `384`, for 384 well plates.
#'   * "custom", for a plate containing user-specified rows and columns to `plate_rows` and `plate_cols`, which are passed to [dimensions_to_wells()].
#' @param ... Unused, for extensibility.
#' @param .as_factor Whether to make the output vector a factor, with the same levels as the order of the vector.
#' @inheritParams dimensions_to_wells
#'
#' @return A character vector where each entry is a unique well name. This vector is a factor if `.as_factor` is set to `TRUE`.
#' @export
#'
#' @examples
#'
#' # generate well names for a full 384-well plate
#' make_well_names(plate_type = 384)
#' # [1] "A1"  "A2"  "A3" . . . "P22" "P23" "P24"
#'
#' # generate well names for a custom plate
#' make_well_names(plate_type = "custom", plate_rows = c("AA", "BB", "CC"), plate_cols = c(1, 2, 3))
#' # [1] "AA1" "AA2" "AA3" "BB1" "BB2" "BB3" "CC1" "CC2" "CC3"
#'
make_well_names <- function(plate_type, plate_rows = NULL, plate_cols = NULL, .leading_zeroes = FALSE, .as_factor = FALSE, ...) {
  # function to create a string of well names for a desired plate type

  # accept number or character input
  plate_type <- as.character(plate_type)

  # guide unusable custom dimensions
  if (plate_type == "custom") {
    if (is.null(plate_rows) | is.null(plate_cols)) {
      stop("For 'custom' plate types, you must supply a vector to both `plate_row` and `plate_col`.")
    }
  }

  # alert if unaccepted plate type
  if (!plate_type %in% c("384", "96", "custom")) {
    stop(paste0("Unknown `plate_type` supplied: ", plate_type, ". Please specify one of: '96', '384', or 'custom'."))
  }

  # Generate well names  --------------------------------------------------------------
  # generate all possible combinations of supplied vectors as
  wells <- switch(plate_type, # accept number or character
    "384" = dimensions_to_wells(plate_rows = LETTERS[1:16], plate_cols = c(1:24), .leading_zeroes),
    "96" = dimensions_to_wells(plate_rows = LETTERS[1:8], plate_cols = c(1:12), .leading_zeroes),
    "custom" = dimensions_to_wells(plate_rows, plate_cols, .leading_zeroes)
  )

  # turn into a factor if requested.
  if (.as_factor) { # order determined by first vector; see dimensions_to_wells() above
    wells <- factor(wells, levels = wells)
  }

  wells
}
